## 进程线程，傻傻分不清楚

浏览器是多进程的，每个进程里面又包含了多线程

简单的理解，以 browser 来说，一个 tab 页就是一个进程

> 官方术语  
> 进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）  
> 线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）

## 浏览器进程

### （只有一个）控制进程（Browser 进程）

浏览器的主进程，负责协调，主控，只有一个

1. 负责浏览器界面显示，用户交互
2. 负责各个页面管理，创建和销毁其他进程
3. 将 Renderer 进程得到的，内存中的 Bitmap，绘制到用户界面上
4. 网络资源的管理，下载

### （可能多个）第三方插件进程

每种类型的插件对应一个进程，仅当使用该插件时才创建

### （最多一个）GPU 进程

用于 3D 绘制

### （可能多个）浏览器渲染进程（Renderer 进程）

又叫浏览器内核，内部是多线程的，并且，默认每个 Tab 页面一个进程，互相不影响，但是某些情况浏览器会将多个进程合并（比如多个空白标签页）

1. 页面渲染，脚本执行，事件处理等

### 多进程的优势

1. 避免单个 page crash 影响整个浏览器
2. 避免第三方插件 crash 影响整个浏览器
3. 多线程充分利用多核优势
4. 方便实用沙盒模型隔离插件等进程，提高浏览器稳定性

当然，内存等资源消耗也会更大

## 浏览器渲染进程

浏览器渲染进程是多线程的，列举一些主要常驻线程

### GUI 渲染线程

1.  负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等
2.  当界面需要重绘（Repaint）或由于某种操作引发回流（reflow）时，该线程就会执行
3.  **注意，和 JS 引擎线程是互斥的**，当 JS 引擎线程执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中**等到 JS 引擎线程空闲时**立即被执行

### JS 引擎线程

1.  也称为 JS 内核（例如 V8 引擎），负责处理 JavaScript 脚本程序
2.  一直等待着任务队列中任务的到来，然后加以处理
3.  一个 Tab 页（Rednerer 进程）中无论什么时候都只有一个 JS 引擎线程在运行
4.  **注意，和 GUI 渲染线程是互斥的**，所以如果 JS 执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞

### 事件触发线程

1.  归属于浏览器而不是 JS 引擎线程，用来控制事件循环
2.  当 JS 引擎线程执行代码时候碰到 setTimeout 时（也可以是来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中
3.  当对应的事件符合触发条件被触发时，该线程会把事件添加到任务队列的队尾，等待 JS 引擎线程的处理
4.  **注意，由于 JS 的单线程关系**，任务队列中的事件都得排队等待 JS 引擎线程处理（等其空闲时才会去执行）

### 定时触发器线程

1.  setInterval 和 setTimeout 所在的线程
2.  浏览器定时计数器并不是由 JS 引擎线程计数的，因为 JS 是单线程的，如果处于阻塞线程状态就会影响计时器的准确
3.  通过单独线程来计时并触发定时，计时完毕后，添加到任务队列中，等待 JS 引擎线程空闲后执行
4.  **注意，setTimeout 中低于 4ms 的时间间隔算为 4ms**，这个是 W3C 在 HTML 标准中规定的

### 异步 http 请求线程

1.  浏览器新开一个线程来应对 XMLHttpRequest 连接
2.  监测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，由 JS 引擎线程处理

## WebWorker

> WebWorker 可以运行在 Web 内容的后台线程，该线程可以执行任务而不干扰用户界面，一个 worker 是使用一个构造函数创建的一个对象，运行一个指定的 JavaScript 文件，worker 运行在另一个全局上下文中，不同于当前的 window，因此如果在 workder 中使用 window 将返回错误

1. 创建 worker 时，JS 引擎线程向浏览器申请开一个子线程，该子线程是浏览器开的，完全受主线程控制，而且不能在里面操作 DOM
2. JS 引擎线程与 workder 线程间通过 postMessage API，需要通过序列化对象来与线程交互特定的数据

### WebWorker 和 SharedWorker

1. WebWorker 只属于某个页面，不会和其他页面的 Renderer 进程共享
   1. 所以 Chrome 在 Renderer 进程中，创建一个新的线程来运行 Worker 中的 JS 代码
2. SharedWorker 是浏览器所有页面共享的，不能采用与 WebWorker 同样的方式实现，因为他不属于某个 Renderer 进程，可以为多个 Renderer 进程共享使用
   1. 所以 Chrome 为 SharedWorker 单独创建一个进程来运行 JS 代码，在浏览器中每个相同的 JavaScript 只存在一个 SharedWorker 进程，不管被创建多少次

本质上是线程和进程的区别，WebWorker 是运行在 Rednerer 进程中的线程中，可以有多个，互相不影响，SharedWorker 是运行在浏览器中的进程，只有一个

## JS 的运行机制

- JS 分为同步任务和异步任务
- 同步任务都在主线程上执行，形成一个执行栈
- 主线程之外，事件触发线程管理着一个**任务队列**，只要异步任务有了运行结果，就在任务队列之中放置一个事件
- 一旦执行栈中的所有同步任务执行完毕，JS 引擎线程空闲，系统会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行

栈：先进后出  
队列：先进先出

## macrotask 和 microtask

### macrotask（宏任务）

每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个时间回调并放到执行栈中执行）

- 每一个 task 会从头到尾将这个任务执行完毕，不会执行其他
- 浏览器为了 JS 内部 task 与 DOM 任务能够有序的执行，会在一个 task 执行结束后，在下一个 task 执行开始前对页面进行重新渲染

形成条件

- 主代码块
- setTimeout
- setInterval

可以看到，事件队列中的每一个事件都是一个 macrotask

macrotask 中的事件都是放在一个事件队列中的，而这个队列由**事件触发线程**维护

### microtask（微任务）

在当前 task 执行结束后立即执行的任务

- 执行的时机在当前 task 任务结束后，下一个 task 任务开始前，**在渲染前**，也就是说在某 macrotask 执行完后，就会把在它执行期间，产生的所有 microtask 都执行完毕
- 响应速度比 setTimeout（setTimeout 是 task）更快，因为无需等待渲染

形成条件

- Promise
- process.nextTick

在 node 环境下，process.nextTick 的优先级高于 Promise，意思是，在 macrotask 任务结束后，会先执行微任务队列中的 nextTickQueue 部分，再执行微任务中的 Promise 部分

microtask 重的所有微任务都是添加到微任务队列（Job Queues）中，这个队列由**JS 引擎线程**维护

### 运行流程

1. 执行一个宏任务（栈中没有的话就从事件队列中获取）
2. 执行过程中如果遇到微任务，就将它添加到微任务队列
3. 宏任务执行完毕后，立即执行微任务队列中所有的微任务
4. 执行完毕，开始渲染，GUI 线程接管渲染
5. 渲染完毕，JS 引擎线程继续接管，开始下一个宏任务

## 散落知识点

### Browser 进程和 Renderer 进程的通信过程

1. Borwser 进程收到用户请求，获取页面内容，比如通过网络下载资源，随后将该任务通过 RenderHost 接口传递给 Renderer 进程
2. Renderer 进程的 Rednerer 接口收到消息，处理后交给渲染线程，开始渲染
   1. 渲染线程接收请求，加载网页并渲染网页，这其中可能需要 Browser 进程获取资源和需要 GPU 进程来帮助渲染
   2. 可能会有 JS 引擎线程操作 DOM（可能会造成回流并重绘）
   3. Renderer 进程将结果传递给 Borwser 进程
3. Browser 进程接收到结果并将结果绘制出来

### GUI 渲染线程与 JS 引擎线程互斥

由于 JavaScript 是可以操作 DOM 的，如果在修改这些元素属性同时渲染界面，即 JS 引擎线程和 GUI 线程同时运行，那渲染线程前后获得的元素数据就可能不一致了

为了防止如上结果，浏览器设置 GUI 渲染线程和 JS 引擎线程为互斥的关系，当 JS 引擎执行时，GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎线程空闲时立即被执行

### JS 阻塞页面加载

比如 JS 引擎线程正在进行巨量的计算，此时就算 GUI 有更新，也会被保存到队列中，等待 JS 引擎线程空闲后执行

### 浏览器渲染流程

1. 浏览器输入 url，浏览器主进程接管，开一个下载线程，进行 http 请求（DNS 查询，IP 寻址等），等待响应，获取内容，将内容通过 RendererHost 接口转交给 Rednerer 进程
2. 浏览器渲染流程开始
3. 解析 HTML 建立 DOM 树
4. 解析 CSS 构建 render 树（将 CSS 代码解析成树形的数据结构，然后结合 DOM 合并成 render 树）
5. 布局 render 树（Layout / reflow），负责各元素尺寸、位置的计算
6. 绘制 render 树（paint），绘制页面像素信息
7. 将各层的信息发送给 GPU，GPU 会将各层合成（composite），显示在屏幕上
8. 渲染完毕之后调用 load 事件

![浏览器渲染流程](https://user-gold-cdn.xitu.io/2018/1/22/1611cb18d3a3938b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### load 事件 与 DOMContentLoaded 事件

当 DOMContentLoaded 事件触发时，仅当 DOM 加载完成，并不包括样式表、图片，比如如果有 async 加载的脚本就不一定完成

当 onload 事件出发时，页面上所有的 DOM、样式表、脚本、图片都已经加载完成了，渲染完毕了

顺序为 DOMContentLoaded -> load

### CSS 加载

**CSS 是由单独的下载线程异步下载的**

- CSS 加载并不会阻塞 DOM 树解析（异步加载时 DOM 照常构建）
- 但会阻塞 render 树渲染（渲染需等 CSS 加载完毕，因为 render 树需要 CSS 信息）

### 普通图层和复合图层

浏览器渲染的图层一般包含两大类：普通图层以及复合图层

普通的文档流可以理解为一个复合图层，这个图层称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中

其实 absolute 布局（fixed 也一样），虽然可以脱离普通文档流，**但它仍属于默认复合层**

可以通过**硬件加速**的方式，声明一个新的复合图层，他会单独分配资源（当然，也会脱离普通文档流，不管复合图层中怎么变化，也不会影响默认复合层里的回流重绘）

#### 验证

Chrome 源码调试 -> More Tools -> Rendering -> Layer borders，黄色的就是复合图层信息

#### 如何变成复合图层（如何启用硬件加速）

- translate3d、translateZ
- opacity 属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
- will-chang 属性，一般配合 opacity 与 translate 使用，作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（最好用完后就释放）
- <video>、<iframe>、<canvas>、<webgl> 等元素
- 其他，比如 flash 插件

#### absolute 和硬件加速的区别

absolute 虽然可以脱离普通文档流，但是无法脱离默认复合层，所以就算 absolute 中信息改变时不会改变普通文档流中的 render 树，但是浏览器最终绘制的时候，是整个复合层绘制的，所以 absolute 中信息的改变仍然会影响整个复合层的绘制

而硬件加速直接就是在另一个复合层了，所以他的信息改变不会影响默认复合层，仅仅是影响最后的合成

#### 硬件加速注意点

硬件加速时，尽可能是用 index，防止浏览器默认给后续的元素创建复合层渲染

原理：webkit CSS3 中，如果某元素添加了硬件加速，并且 index 层级比较低，那么在这个元素后面的其他元素（层级比这个元素高的，或者相同的，并且 relative 或者 absolute 属性相同的），会默认变成复合层渲染，如果处理不当会极大的影响性能

就是说存在一个隐式合成的概念：如果 a 是一个复合图层，而且 b 在 a 上面，那么 b 也会被隐式转为一个复合图层

### setTimeout 和 setInterval

用 setTimeout 模拟定期计时和直接用 setInterval 是有区别的，每次 setTimeout 计时到后就会去执行，然后执行主代码一段时间之后再启动一个 setTimeout，中间就多了运行主代码的误差

而 setInterval 则是每次都精确的隔一段时间推入一个事件

#### setInterval 的问题

1. 累积效应，如果主代码运行的时间不确定，在下一个 setInterval 事件添加到队列之前还没完成，就会积累代码，导致定时器代码连续运行好几次，而且之间没有间隔
2. 把浏览器最小化后，setInterval 并不是不执行程序，而是把 setInterval 的回调函数放在队列中，等浏览器窗口再次打开时，依次执行

JS 引擎会对 setInterval 进行优化，如果当前任务队列中有 setInterval 的回调，就不会重复添加

### Promise

官方的版本是标准的 microtask 形式，而用 polyfill 实现的一般是通过 setTimeout 模拟的，所以是 macrotask 形式

#### 模拟 Promise

用 MutationObserver 实现 microtask，这是 HTML5 中的新特性，作用是监听一个 DOM 变动，当 DOM 对象树发生任何变动时，MutationObserver 会得到通知

用 MessageChannel 实现，他属于宏任务，优先级大于 setTimeout

## 问题

1. 那 fetch 是在哪个线程被创建的？
2. Renderer 进程中还有哪些线程？
3. iframe 的渲染是在同一个进程中吗？
4. 有哪些队列？事件队列，任务队列，GUI 更新队列？微任务队列
5. 输入一个 url 之后发生了什么事情？
6. 解析 CSS 树和 HTML 树是同时进行的么？

## 其他

IOS 的 webview，或者 Safari 等浏览器有一个特点，在滚动的时候不执行 js
