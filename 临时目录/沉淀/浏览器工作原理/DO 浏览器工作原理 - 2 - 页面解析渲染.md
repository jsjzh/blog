## 参考

- https://github.com/ljianshu/Blog/issues/51
- placeholder

## 前言

上篇说完了解析 url，我们接下来说获取到 html 文件之后，浏览器在获取到 html 资源之后，就开始解析，生成 dom 树 css 树，最后合并成了 render 树

## 简单总结

1. 解析 dom 树

## 启程

一切还要从我们获取到了 html 文件说起，其实服务端返回给我们的就是一堆 html 格式的字符串

![浏览器渲染过程](https://camo.githubusercontent.com/2f8e4192ed63300d9c1d508c6936b8cda5f9fb3b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32372f313637663035373730346239346630383f773d37303526683d32323726663d706e6726733d313630323734)

## 解析

解析的过程可以分成两个子过程：词法分析和语法分析。

词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词。

语法分析是应用语言的语法规则的过程。

解析器通常将解析工作分给以下两个组件来处理：词法分析器（有时也称为标记生成器），负责将输入内容分解成一个个有效标记；而解析器负责根据语言的语法规则分析文档的结构，从而构建解析树。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。

解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。

如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。

### 解析器类型

有两种基本类型的解析器：自上而下解析器和自下而上解析器，直观地来说，自上而下的解析器从语法的高层结构出发，尝试从中找到匹配的结构。而自下而上的解析器从低层规则出发，将输入内容逐步转化为语法规则，直至满足高层规则。

### html 解析器

由于 html 的如下特殊性，不能够使用常规的解析方法，所以针对 html 有特殊的解析器，[HTML5 规范描述的解析算法](https://html.spec.whatwg.org/multipage/parsing.html)

- 语言的宽容本质，不需要严格的闭合标签
- 对于常见的无效 html 用法不会报错
- 解析过程需要不断反复，因为输入内容在解析过程中可能会改变，比如代码里写了 document.write，这会改变解析器的输入内容

html 解析算法

该算法由两个阶段组成：标记化和树构建

标记化是词法分析过程，将输入内容解析成多个标记，传递给树构造器，然后接受下一个字符以识别下一个标记，以此往复直到解析结束

标记化算法

通过一个简单的例子来看该算法的流程

```html
<html>
  <body>
    Hello world
  </body>
</html>
```

1. 状态机的初始状态是**数据状态**
2. 遇到字符 `<`，状态改为**标记打开状态**
   接受一个 `a-z` 字符，创建起始标记，状态改为**标记名称状态**，并且，在遇到 `>` 之前，接收到的每个字符都会附加到标记名称上，比如 `h -> ht -> htm -> html`
3. 在遇到字符 `>`，状态改为**数据状态**
4. 在接受到 `</body>` 的 `<` 字符之后，状态变为**标记打开状态**
5. 接受 `/` 字符时，会创建 end tag token，状态变为**标记名称状态**
6. 直到接收到 `>`，状态回到**数据状态**

经过一个完整的流程之后，可以发现状态机的状态仍旧是数据状态

树构建算法

在创建解析器的同时，也会创建 Document 对象，在树构建阶段，以 Document 为根节点的 DOM 树也会不断进行修改，标记生成器发送的每个节点都由树构建器进行处理，并且，在规范中定义了每个标记他所对应的 DOM 元素，这些元素在接收到相应的标记的时候被创建，并且，这些元素不仅会添加到 DOM 树中，还会添加到开放元素的堆栈中，次堆栈用于纠正嵌套错误和处理未关闭的标记，他的算法也可以用状态机来描述，这些状态成为插入模式

```html
<html>
  <body>
    Hello world
  </body>
</html>
```

1. 在构建之初，第一个模式是 initial mode
2. 接收到 html 标记之后，转为 before html 模式，在该模式下会创建一个 HTMLHtmlElement 元素，添加到 Document 根对象上
3. 状态改为 before head，此时接收 body 标记，即使没有写 head 标记，也会自动创建一个 HTMLHeadElement 元素，添加到树中
4. 进入了 in head 模式，但因为 head 没有内容，转入 after head 模式，系统对 body 标记进行重新处理，创建并插入 HTMLBodyElement 元素，模式变为 inbody
5. 接收由 Hello world 字符串生成的字符标记，在接收第一个字符时会创建并插入 Text 节点，其他字符也会附加到该节点
6. 接收 body 结束标记后，触发 after body 模式，紧接着接收 html 结束标记，模式变为 after after body 模式
7. 再接收到文件结束标记后，解析过程结束

解析结束后，浏览器会把文档标注为交互状态，并开始解析那些处于 deferred 模式的脚本，然后文档状态设置 complete，一个 load 事件随之触发

css 解析

css 是上下文无关的语法，素以可以使用常见的解析器进行解析

不管哪种解析器，最后都会把 css 文件解析成 StyleSheet 对象，且每个对象都包含 css 规则，css 规则对象则包含选择器和声明对象，以及其他与 css 语法对应的对象

script 脚本

有两种情况

1. 一个是 html 页面上写 script 代码，解析器碰到这样的 script 标记时，会立即解析并执行代码，并且，文档的解析将停止，直到脚本解析完毕
2. 如果脚本是外部的，那么解析也会停止，直到资源下载完毕，执行完毕

如果使用了 defer 或者 async，将不会停止文档解析

预解析

在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源，通过这种方式资源可以在并行连接上家在，从而提高总体速度

预解析器不会修改 DOM 树，这项工作由主解析器处理，预解析器只会解析外部资源（例如外部脚本，样式表和图片）

样式表

另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。

render tree

由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示

render tree 中的元素我们称为 renderer，每一个 renderer 都代表了一个矩形的区域，它包含宽度高度位置等几何信息，并且，框的类型受到 display 样式属性影响

```c++
class RenderObject{
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node;  //the DOM node
  RenderStyle* style;  // the computed style
  RenderLayer* containgLayer; //the containing z-index layer
}
```

render tree 和 dom tree

非可视化的 dom 元素并不会插入到 render tree 中，例如 head 元素，如果元素的 display 属性为 none，那么也不会显示在 render tree 中（但是 visibility 属性为 hidden 的元素仍会显示）

有一些 dom 元素对应多个可视化对象，他们往往是具有复杂结构的元素，无法用单一的矩形来描述，例如 select 元素有 3 个 renderer，一个用于显示区域，一个用于下拉列表框，一个用于按钮；并且，如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也是会作为新的 renderer 而添加

根据 css 规范，inline 元素只能包含 block 元素或 inline 元素中的一种，如果出现了混合使用的情况，会匿名创建 block renderer，用来包裹 inline 元素

有一些呈现对象对应于 DOM 节点，但在树中所在的位置与 DOM 节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。
