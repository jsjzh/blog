> 也许大海给贝壳下的定义是珍珠，也许时间给煤炭下的定义是钻石

Web 使用名为 HTTP 的协议作为规范，完成从客户端到服务器端等一系列运作流程

HTTP（HyperText Transfer Protocol），超文本传输协议，严谨的译名应该为超文本转移协议

# HTTP

## 三项 WWW 构建技术

- 把 SGML（标准通用标记语言）作为页面的文本标记语言的 HTML（超文本标记语言）
- 作为文档传递协议的 HTTP
- 指定文档所在地址的 URL（统一资源定位符）

## 网络基础 TCP/IP 协议族

HTTP 属于 TCP/IP 内部的一个子集

TCP/IP 协议族

> 协议：计算机与网络设备要相互通信，双方就必须基于相同的方法，所有的规则就称之为协议

### TCP/IP 的分层管理

TCP/IP 协议族按照层次分别为以下四层，应用层，传输层，网络层和数据链路层

#### 应用层

应用层决定了向用户提供应用服务时通信的活动

TCP/IP 协议族内预存了各类通用的应用服务，比如 FTP（文件传输协议）和 DNS（域名系统）服务就是其中两类

HTTP 协议也处于该层

#### 传输层

传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输

在传输层有两个性质不同的协议：TCP（传输控制协议）和 UDP（用户数据报协议）

#### 网络层（又名网络互联层）

网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方

雨对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线

#### 链路层（又名数据链路层，网络接口层）

用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内

### TCP/IP 通信传输流

![通信传输流](./img/通信传输流.png)

用 HTTP 举例，作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求

接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层

在网络层（IP 协议），增加组为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了

接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层，当传输到应用层才能算真正接收到由客户端发送过来的 HTTP 请求

![通信传输流-封装](./img/通信传输流-封装.png)

发送端在层与层之间传输数据时，**每经过一层时必定会被打上一个该层所属的首部信息**

反之，接收端在层与层传输数据时，**每经过一层时都会把对应的首部消去**

这种把数据信息包装起来的做法称为封装

## 与 HTTP 关系密切的协议：IP、TCP 和 DNS

### 负责传输的 IP 协议

按层次分，IP 网际协议位于网络层

几乎所有使用网络的系统都会用到 IP 协议，TCP/IP 协议族中的 IP 指的就是网际协议，协议名称中占据刻一半位置

但是要注意 IP 和 IP 地址不是一个意思，IP 其实是一种协议的名称

IP 协议的作用是把各种数据包传送给对方，而要保证确实传送到对方那里则需要满足各类条件，其中两个重要的条件是 IP 地址和 MAC 地址

IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址，IP 地址可以和 MAC 地址进行配对，IP 地址可变换，但 MAC 地址基本上不会更改

#### 使用 ARP 协议凭借 MAC 地址进行通信

![ARP中转](./img/ARP中转.png)

IP 间的通信依赖 MAC 地址，在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方，而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标，这时，就会采用 ARP 协议。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址

### 确保可靠性的 TCP 协议

按层次分，TCP 位于传输层，提供可靠的字节流服务

所谓的字节流服务是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理

而可靠的传输服务是指，能够把数据准确可靠地传输给对方

TCP 协议为了更容易传送大数据才把数据分割，并且 TCP 协议能够确认数据最终是否送达到对方

#### 三次握手策略

![TCP 三次握手](./img/TCP三次握手.png)

用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，他一定会向对方确认是否成功送达

握手过程中使用了 TCP 的标志（flag）--- SYN 和 ACK

- 发送端首先发送一个带 SYN 标志的数据包给对方
- 接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息
- 发送端再回传一个带 ACK 标志的数据包，代表握手结束

**若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包**

除了三次握手，TCP 协议还有其他各种手段来保证通信的可靠性

## 负责域名解析的 DNS 服务

DNS 服务是和 HTTP 协议一样位于应用层的协议，它提供域名到 IP 地址之间的解析服务

计算机既可被赋予 IP 地址，也可以被赋予主机名和域名，如 www.github.com

这是为了方便用户记忆，但计算机更擅长处理一长串数字

为了解决上述的问题，DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务

![DNS服务](./img/DNS服务.png)

## 各种协议与 HTTP 协议的关系

![各种协议和HTTP协议的关系](./img/各种协议和HTTP协议的关系.png)

- 客户端向 DNS 服务询问域名对应的 IP 地址，DNS 服务返回 IP 地址
- HTTP 协议生成针对该 IP 地址的服务器的 HTTP 请求报文
- TCP 协议为了方便通信，将 HTTP 请求报文按序号分割成报文段
- IP 协议搜索对方的地址，一边中转一边传送
- TCP 协议从对方接收到报文段，按序号重组报文段
- HTTP 协议对服务器请求的内容的处理
- 得到资源之后反向来一遍就到达了客户端手中

## URI 和 URL

与 URI（统一资源标识符）相比，我们更熟悉 URL（统一资源定位符）

### URI 统一资源标识符

URI 就是由某个协议方案表示的资源的定位标识符，协议方案是指访问资源所使用的协议类型名称

采用 HTTP 协议时，协议方案就是 http，除此之外还有 ftp、mailto、telnet、file 等

URI 用字符串标识某一互联网资源，而 URL 标识资源的地点（互联网上所处的位置），可见 URL 是 URI 的子集

### URI 格式

表示指定的 URI，要使用涵盖全部必要信息的绝对 URI、绝对 URL 以及相对 URL

绝对 URL 的格式

http://user:pass@www.example.com:80/dir/index.html?uid=1#header1

- http 协议名
  - 使用 http: 或 https: 等该协议方案名获取访问资源是要指定协议类型
  - 也可使用 data: 或 javascript: 这类指定数据或脚本程序的方案名
- user:pass 登陆信息（认证）
  - 指定用户名和密码作为从服务器端获取资源时必要的登陆信息，可选项
- www.example.com 服务器地址
  - 使用绝对 URI 必须指定服务器地址，可以是域名，或是 192.168.1.1 这类 IPv4 地址名，还可以是 [0:0:0:0:0:0:0:1] 用方括号括起来的 IPv6 地址名
- :80 服务器端口号
  - 指定服务器连接的网络端口号，可选项，若省略则自动使用默认端口号
- dir/index.html 带层次的文件路径
  - 指定服务器上的文件路径来定位特指的资源
- uid=1 查询字符串
  - 针对已制定的文件路径内的资源，可以使用查询字符串传入任意参数，可选项
- header1 片段标识符
  - 使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置），**但在 RFC 中比并没有明确规定其使用方法**，可选项

![RFC说明](./img/RFC说明.png)

# 简单的 HTTP 协议

## HTTP 协议用于客户端和服务器端之间的通信

两台计算机作为客户端和服务端的角色有可能会互换，但就仅从一条通信路线来说，角色是确定的，而用 HTTP 协议能够明确区分两端

## 通过请求和响应的交换达成通信

请求必定由客户端发出，而服务器端回复响应

HTTP 协议规定，请求从客户端发出，最后服务端响应该请求并返回，换句话说，客户端是主动端，服务端是被动端

![请求报文](./img/请求报文.png)

```
GET /index.html HTTP/1.1
Host: github.com
```

请求报文其实行开头的 GET 表示请求访问服务器的类型，随后的字符串 /index.html 指明了请求访问的资源对象，也就做请求 URI，最后的 HTTP/1.1 表示 HTTP 的版本号

请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的

```
POST /from/entry HTTP/1.1
Host: github.com
Connection: keep-alive
Content-Type: appliccation/x-www-form-urlencoded
Content-Length: 16

name=github&age=10
```

- POST 方法
- /form/entry URI
- HTTP/1.1 协议版本
- HOST...Content-Length 请求首部字段
- name...age 内容实体

服务器接收到请求之后会将请求内容的处理结果以相应的形式返回

响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用于解释状态码的原因短语、可选的响应首部字段以及实体主体构成

```
HTTP/1.1 200 OK
Date: ...
Content-Length: 362
Content-Type: text/html

<hmtl>
...
</html>
```

- HTTP/1.1 表示服务器对应的 HTTP 版本
- 200 OK 表示请求的处理结果状态码（200）和原因字段（OK）
- Date 表示创建响应的日期时间
- Date...Content-Type 响应首部字段
- \<html\>...\<\/html\> 主体

## HTTP 是不保存状态的协议

HTTP 是无状态协议，HTTP 协议自身不对请求和响应之间的通信状态进行保存

也就是说在 HTTP 这个级别，协议对于发送过的请求或相应都不做持久化处理

使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产生，协议本身并不保留之前一切的请求或响应报文的信息，这是为了更快处理大量事务

为了保存用户的登陆状态，引入了 Cookie 技术，有了 Cookie 再用 HTTP 协议通信，就可以管理状态了

## 请求 URI 定位资源

除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以用一个 \* 来代替请求 URI

```
OPTIONS * HTTP/1.1
```

## 告知服务器意图的 HTTP 方法

- GET
  - 用来请求访问已被 URI 识别的资源，制定的资源经服务器端解析后返回响应内容
  - 也就是说如果请求的资源是文本，那就保持原样返回
  - 如果是像 CGI（通用网关接口）那样的程序，则返回经过执行后的输出结果

```
GET /index.html HTTP/1.1
Host: www.github.com
```

↓↓↓

```
返回 index.html 的页面资源
```

```
GET /index.html HTTP/1.1
Host: www.github.com
If-Modified-Since: ...
```

↓↓↓

```
仅返回 If-Modified-Since 之后的事件更新过的 index.html 页面资源，如果未有内容更新，则以状态码 304 Not Modified 作为状态码返回
```

- POST
  - 用来传输实体的主体
  - 虽然用 GET 也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST
  - 虽说 POST 和 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容

```
POST /submit HTTP/1.1
Host: www.github.com
Content-Length: 1024（1024字节的数据）
```

↓↓↓

```
返回 submit 接收数据的处理结果
```

- PUT
  - 用来传输文件，就像 FTP 协议的文件上传一样
  - 要求在请求报文的主体中包含文件内容
  - 然后保存到请求 URI 制定的位置

> 但是鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般不使用该方法，若配合 Web 应用程序的验证机制，或架构设计采用 REST（表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法

```
PUT /example.html HTTP/1.1
Host: www.github.com
Content-Type: text/html
Content-Length: 1024（1024字节的数据）
```

↓↓↓

```
响应返回状态码为 204 No Content（比如：该 html 已存在与服务器上）
```

- HEAD
  - 和 GET 方法类似，只是不返回报文主体部分
  - 用于确认 URI 的有效性及资源更新的日期时间等

```
HEAD /index.html HTTP/1.1
Host: www.github.com
```

↓↓↓

```
返回 index.html 有关的响应首部
```

- DELETE
  - 用来删除文件，与 PUT 相反的方法

```
DELETE /example.html HTTP/1.1
Host: www.github.com
```

↓↓↓

```
响应返回状态码 204 No Content（比如：该 html 已从该服务器上删除）
```

- OPTIONS
  - 询问支持的方法
  - 用来查询针对请求 URI 制定的资源支持的方法

```
OPTIONS * HTTP/1.1
Host: www.github.com
```

↓↓↓

```
HTTP/1.1 200 OK
Allow: GET,POST,HEAD,OPTIONS（返回服务器支持的方法）
```

- TRACE
  - 让服务端将之前的请求通信环回给客户端的方法
  - 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务端就把该数字减 1
  - 当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务端则返回状态码 200 OK 的响应
  - 客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/篡改的
  - 这是因为请求想要连接到源目标服务器可能会通过代理中转
  - TRACE 方法就是用来确认连接过程中发生的一系列操作
  - 但是，这个方法本来就不怎么常用，再容易引发 XST（跨域追踪）攻击，就更不会用到了

![TRACE](./img/TRACE.png)

```
TRACE / HTTP/1.1
Host: www.github.com
Max-Forwards: 2
```

↓↓↓

```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 1024

TRACE / HTTP/1.1
host: www.github.com
Max-Forwards: 2（返回响应包含请求内容）
```

- CONNECT
  - 要求用隧道协议连接代理
  - 该方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信
  - 主要使用 SSL（安全套接层）和 TLS（传输层安全）协议把通信内容加密后经网络隧道传输

![CONNECT](./img/CONNECT.png)

```
CONNECT proxy.github.com:8080 HTTP/1.1
Host: proxy.github.com
```

↓↓↓

```
HTTP/1.1 200 OK（之后进入网络隧道）
```
