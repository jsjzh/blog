# 手拉手一步步带你认识编码

<div align="center">
  <image src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d45a010de01a413ab7101a4479b1ad5e~tplv-k3u1fbpfcp-zoom-1.image" />
</div>

## 前言

其实这篇文章是在写上传文件的文章的时候产生的，因为上传文件的时候会涉及到文件的基本组成，还有编码等内容，我又是个不彻底搞清楚就不罢休的人，往往会因为一个小问题牵扯出来一堆问题，接着，疑问又带来新的疑问（禁止套娃！），写这篇文章真的花了很长的时间，如果看完之后有所收获，一个赞就是对我最好的褒奖。

ps: 文章不会纠结一些不太重要的信息，比如某协议是谁提出的，在什么年份提出的，这些基本上看过一次就忘了，也不重要，我会提取重要的信息来分享给大家。

## 前置知识

### 计算机的单位换算

二进制位、位、比特、bit、b
字节、Byte、B
kb、mb

## 计算机之初，杂乱无法统一的编码方案

### 计算机和 ASCII 的到来

众所周知，在计算机中，所有的数据存储和运算时都要使用二进制表示，因为计算机用高电平和低电平表示 1 和 0。然后在美国就有这么一群人，他们决定用 8 个二进制位来表示所有字符。

8 个二进制位，一共可以表示 `2^8 = 256` 个字符，而这些字符又分为控制字符、通信专用字符和可显示字符。

控制字符和通信专用字符放在一起说，第 0~31，再加上 127，一共是 33 个。比如，`0000 0111`，十六进制是 `0x07`，表示的意思是响铃，计算机在接收到 `0000 0111` 的时候就会铃铃作响。

可显示字符，第 32~126，一共是 95 个，比如 `0011 0000`，十六进制是 `0x30`，表示的意思是 0，再比如 `0100 1010`，十六进制是 `0x4A`，表示的是大写英文字母 J。

因为计算机刚开始只在美国使用，那大家相安无事，用的挺好，这就是我们在大学 C 语言里面认识到的 ASCII 码表的由来。

> ps: 现在教育太疯狂了，认识的小孩小学就在学编程，他现在就知道 ASCII 码了

### ASCII 的扩展以及 GBK 编码方案

后来，因为计算机的发展，一些西方国家开始在 ASCII 码表的后面增加自己国家的字符和制表符等字符，这就是我们知道的 扩展 ASCII 码表，他占用了 128~255 的位置来表示一些字符。

> ps: 扩展 ASCII 码表在不同系统配置的内码表也不同，这里就不赘述了，想要了解的同学可以参考以下文档

https://baike.baidu.com/item/%E6%89%A9%E5%B1%95ASCII/9882009

再后来，计算机发展的越来越快，来到了第三世界。我们发现，泱泱中华数以万计的文字，ASCII 码表是不可能放下我们的字符了，256 个位置全给我们都不够，那该怎么办？

聪明的中国人直接把 127 号码位之后的奇怪符号取消掉，规定，一个小于 127 的字符意义与原来相同，但两个大于 127 的字符连在一起时，就表示一个汉字，前面的一个字节（高字节）从 `0xA1~0xF7`，后面一个字节（低字节）从 `0xA1~0xFE`。

这样我们就能组合出八千多个位置来放自己的文字、数学符号、日文假名等，而且，我们甚至把原先在 ASCII 码表里就有的标点符号，又全部编了两个字节长的字符，这就是我们常说的全角字符了，而 127 号以下的就称为半角字符。（「,」和「，」看出不同了吗？前者是半角字符，后者是全角字符）

后来这个方案用着还不错，我们就给它取了个名字 `GB2312`，前面的 GB 意思是国标。

但是中国的汉字实在太多了，八千多个位置还是不够，那我们干脆就不要求低字节是 127 号之后的了，规定只要高字节大于 127，那就是中国编码方案的开始。

这个方案就称为 `GBK`，`GBK` 不仅包括了 `GB2312` 的所有内容，还增加了好多汉字和繁体字。

再后来，少数民族也要用电脑了，要把他们的文字也加进去，于是就再进行扩展，`GBK` 扩成了 `GB18030`。

听起来是不是挺完美的？`GB18030`，几乎可以囊括你能见到的所有中文，但是我们这只解决了中文的编码，无法显示其他国家或者地区的文字，比如，那时候还有一个编码方案叫 `Big5`，普及与台湾、香港、澳门等繁体中文通行区，倚天中文系统、window 繁体中文等系统的字符集都是以 `Big5` 为基准。你看，中国的内地和港澳台编码方式都不一样，我们和其他国家就更不用说了，结果就是，大家都闭门造车，自嗨，如果需要看其他国家的文档那就得配置其他国家的编码方案。

## UNICODE 万国码的问世

再这么混乱下去肯定不行，这时候，创建一个可以囊括全世界的字符集势在必行，这个时候，有两个组织开始着手统一字符集，国际标准化组织（ISO）开发的 ISO 10646 字符集，统一码联盟开发的 UNICODE 字符集。再后来，两个组织都意识到他们应该做的事情是统一标准而不是重蹈覆辙，于是他们决定合作，最终才有了我们在用的 UNICODE 字符集，当然 ISO 10646 字符集依然存在，并且和 UNICODE 共存，但是他们各自的码位所表达的字符都相同。

因为我们比较熟悉的是 UNICODE，所以接下来我都会以 UNICODE 为主，捎带着讲解一下 ISO 编码方案。

刚开始 UNICODE 的做法很简单，ASCII 1 个字节（8 位）不是不够吗，那就 2 个字节（16 位），`2^16 = 65536` 总够了吧？

### UNICODE 平面的含义以及码位区段说明

结果是被啪啪打脸，在被各个国家的字符蹂躏了一遍之后，不行，这得改，于是决定取 UNICODE 中的两段区域 `0xD800~0xDBFF`（叫做高代理位）和 `0xDC00~0xDFFF`（叫做低代理位），用他们来组成新的码位。每段代理位都有 1024 位，那就是增加了 `1024^2 = 1048576` 个码位，再加上原先的 `2^16 ` ，所以按道理来说，UNICODE 一共有 `1114112` 个码位。

现在我们有正常 2 个字节的码位，还有高代理位和低代理位组成的 4 个字节的码位，我们该怎么区分他们呢？于是，这些码位就象征意义上的被分成了不同平面，2 个字节的是 BMP 平面，4 个字节的是辅助平面。

> 第 0 平面称为 BMP 其范围为 `0000-FFFF`。  
> 第 1 辅助平面称为 SMP 又称为多文种补充平面，其范围为 `10000-1FFFF`。  
> 第 2 辅助平面称为 SIP，又称为表意文字补充平面，其范围为 `20000-2FFFF`。  
> 第 3 辅助平面称为 TIP，又称为表意文字第三平面，其范围为 `30000-3FFFF`。  
> 第 4 至 13 辅助平面尚未使用。  
> 第 14 辅助平面称为 SSP，又称为特殊用途补充平面，其范围为 `E0000-EFFFF`。  
> 第 15 辅助平面，其范围为 `F0000-FFFFF`。  
> 第 16 辅助平面，其范围为 `100000-10FFFF`。

其实没有平面这么一说，只是把相同长度的区段取了不同名字而已。我们常用的字符都在 BMP 平面，看下图，从 `0x0000~0xFFFF` 一共 65536 个码位，其中高代理位和低代理位组合成了辅助平面。

「TODO」画一个图，内容如下

<!-- 0x0000                                                                           0xFFFF -->
<!-- 0x0000~0x007F    0x4E00~0x9FFF     0xD800~0xDBFF  0xDC00~0xDFFF    0xE000~0xF8FF -->
<!--     ASCII         2W 多个汉字           高代理位        低代理位         自行使用区 -->

另外，有兴趣的同学可以到 [这个网站](https://www.unicode.org/charts/) 上查看所有平面上有哪些字符。

等等，取代理位的操作是不是很熟悉？看文章仔细的同学应该马上就反应过来了，对，没错，就像当初我们针对 ASCII 而提出的 `GBK` 方案，我们用 127 号以后的 ASCII 码组合出几万个码位给汉字用，UNICODE 也是一样，取了两段代理位组合成了辅助平面，那为什么 UNICODE 的码位有几百万个，而我们提出的 `GBK` 只有几万，因为 ASCII 只有 1 个字节，UNICODE 有 2 个字节，仅此而已。ASCII 和 UNICODE 本质其实都一样，就是字符集，字节数不同而已。

那我们有了 UNICODE 字符集问题就解决了吗？其实并没有，实际情况是，由于 UNICODE 一开始就没有打算去兼容之前的字符集，比如 ASCII，所以 UNICODE 刚开始的推广之路并不平坦。

这时候有同学可能会问了，你上面的图画的，UNICODE 不是把 ASCII 前一半的字符拿去了吗？而且每个码位对应的字符都一样，为啥就不兼容了？

这个就看的很细心了，但是 ASCII 是 1 个字节的，而 UNICODE 的 BMP 平面是 2 个字节的，同样表达英文字母 `A`，ASCII 是 `01000001`，而 UNICODE 是 `00000000 01000001`。

### 解决兼容问题，UTF-8 编码方案的提出

这个时候，为了兼容 ASCII，UNICODE 字符集的编码方案，UTF-8 就出现了，他不仅可以兼容 ASCII，并且由于它是可变长编码方案，对于纯英文的文档，可以使空间使用减半。

但是对于中文文档，相对于 GBK 编码方案还是导致空间增加了，因为原先我们 GBK 用 2 个字节组合出了几万个码位，但在 UTF-8 中，即使是 BMP 平面的汉字，那也需要 3 个字节。为什么？我们直接看下面的例子，对于”裤裆“的”裤“字，UTF-8 是如何编码的。

这里有一个表格，是 UTF-8 的替换模板，模板也是有规律的，如果开头是 0，那就占用一个字节，如果开头是 1，那连续几个 1 就表示有几个字节。

| 十六进制范围       | UTF-8 模板                          |
| :----------------- | :---------------------------------- |
| U+ 0000 ~ U+ 007F  | 0XXXXXXX                            |
| U+ 0080 ~ U+ 07FF  | 110XXXXX 10XXXXXX                   |
| U+ 0800 ~ U+ FFFF  | 1110XXXX 10XXXXXX 10XXXXXX          |
| U+10000 ~ U+10FFFF | 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX |

```javascript
// 获取”裤“的 UNICODE 码位
const code = "裤".charCodeAt(); // 35044
// 获取 35044 的十六进制表示，88e4 位于上表的第 3 行
const hex = code.toString(16); // 88e4
// 获取 35044 的二进制表示
const binary = code.toString(2); // 1000 1000 1110 0100

// 将二进制带入模板

//          10001000 11100100   |   ”裤“的二进制序列
//     1000   100011   100100   |   ”裤“的二进制排序后
// 1110XXXX 10XXXXXX 10XXXXXX   |   模板中的第三行
// --------------------------   |   从低位到高位带入模板
// 11101000 10100011 10100100   |   获得二进制序列
//       e8       a3       a4   |   二进制序列转为十六进制

// 最终得到 e8 a3 a4 的编码结果

// 通过 node Buffer 来验证
const buffer = new Buffer.from("裤", "utf-8"); // <Buffer e8 a3 a4>
```

如上我们可以看到，汉字在经过 UTF-8 编码后，变成了 3 个字节，而原先 GBK 我们使用 2 个字节就可以表示，另外，我们也写一下英文字母经过 UTF-8 编码后会获取到多少字符。

```javascript
// 获取 A 的 UNICODE 码位
const code = "A".charCodeAt(); // 65
// 获取 65 的十六进制表示，41 位于上表的第 1 行
const hex = code.toString(16); // 41
// 获取 65 的二进制表示
const binary = code.toString(2); // 1000001

// 将二进制带入模板

//  1000001   |   A 的二进制序列
// 0XXXXXXX   |   模板中的第一行
// --------   |   从低位到高位带入模板
// 01000001   |   获得二进制序列
//       41   |   二进制序列转为十六进制

// 最终得到 41 的编码结果

// 通过 node Buffer 来验证
const buffer = new Buffer.from("A", "utf-8"); // <Buffer 41>
```

可见，对于英文字母来说，`00000000 01000001` 变成了 `01000001`，所占空间减少了一半。

### UTF-16 编码方案

说完了 UTF-8，我们来说说 UTF-16 和 UCS-2，后面还有 UTF-32 和 UCS-4，上面我们不是提到了 ISO 组织么？UCS 就是该组织提出的编码方案。

虽然看着 UTF-16 和 UTF-8 是 double 的样子，但其实他们一点都不一样，首先，对于 BMP 面的字符，UTF-16 就直接用 2 个字节来表示，包括英文字母，另外，我们刚才不是提到高代理位和低代理位，还有辅助平面么？忘了的同学可以翻上去看看，其实高代理位和低代理位就是专门用于 UTF-16 的，对于辅助平面的字符，UTF-16 就用 4 个字节来表示，也就是高代理位和低代理位组合表示。

看了这么久文章，同学们该饿了吧，我们说点好吃的，陕西的特产，biangbiang 面。

![](http://qqpublic.qpic.cn/qq_public/0/0-2560805590-0648CC2C80E2EACE8884836070D0CF39/0)

这个 biang 字，如下图。

![biang](https://pic4.zhimg.com/v2-2323fe3588485d420f3d1a6e2d7f9193_b.jpg)

biang 在 UNICODE 的码位为 `0x30EDE`，你可以打开 [这个网站](https://www.unicode.org/charts/PDF/U30000.pdf)，搜索 `0x30EDE` 来查看 biang 字收录在 UNICODE 字符集中的样子。虽然这个字在浏览器中还不能够打出来，但是我们可以用这个字做引子，来说说 UTF-16 的编码该如何实现。

```javascript
biangCharCodeHex = "0x30EDE";
// 从 200414 这个码位可以看出来，biang 字不在 BMP 平面
// 因为 BMP 平面只有 65536 个码位
parseInt("0x30EDE"); // 200414

// 接下来演示 UTF-16 编码过程

// 先获取 200414 的二进制表示
(200414).toString(2); // 11 0000 1110 1101 1110

//            11 0000 1110 1101 1110   |   码位对应的二进制
//             1 0000 0000 0000 0000   |   减去 0x10000
//            10 0000 1110 1101 1110   |   得到的二进制
//          0010 0000 1110 1101 1110   |   把得到的二进制前补 0 到 20 位
//       0010000011       1011011110   |   整理一下，10 位一隔，方便阅读
// 1101100000000000 1101110000000000   |   左边是 0xD800，右边是 0xDC00
// ---------------------------------   |   还记得高代理位和低代理位的区间么？
//                                     |   高代理位从 0xD800~0xDBFF，我们取 0xD800
//                                     |   低代理位从 0xDC00~0xDFFF，我们取 0xDC00
// 1101100010000011 1101111011011110   |   直接把 10 位分别取代代理位后面的 0，从后面开始取代
//             d883             dede   |   把上述二进制转为 16 进制，最终获取到 UTF-16 编码

// 通过 node Buffer 来验证
// 因为 node 只支持 UTF-16 小端序
// http://nodejs.cn/api/buffer.html#buffer_buffers_and_character_encodings
// 所以表示为 dede 83d8，注意，这是从右往左读的
// 另外 "\u{30EDE}" 这是个 ES6 用来表示辅助平面的字符的方法
const buffer = new Buffer.from("\u{30EDE}", "utf16le"); // <Buffer 83 d8 de de>
```

以上，我们就完成了 UTF-16 编码，另外 UNICODE3.0 也给出了辅助平面字符的转换公式

```javascript
High = Math.floor((charCode - 0x10000) / 0x400) + 0xd800;
Low = ((charCode - 0x10000) % 0x400) + 0xdc00;

// 我们把刚才 biang 的码位代入试试
High = (Math.floor((0x30ede - 0x10000) / 0x400) + 0xd800).toString(16); // d883
Low = (((0x30ede - 0x10000) % 0x400) + 0xdc00).toString(16); // dede
```

在上面的例子里我们也看到了，UTF-16 还存在大端序和小端序，也就是字节序（BOM）的问题，其实就是从左开始读还是从右开始读，得告诉程序才行。

举个例子，“奠”的编码结果是 `5960`，“恙”的编码结果是 `6059`，如果没有表明读取的方向，那程序应该怎么解析文档？

我们知道了 UTF-16 可以用高低代理位组合成新的码位，UCS-2 和 UTF-16 的区别就在此，UCS-2 是用 2 个字节表示 BMP 平面的字符，但是 UCS-2 不能表示辅助平面，并且，由于 ISO 要保证和 UNICODE 保持一致，所以 UCS-2 的 `0xD800~0xDBFF` 和 `0xDC00~0xDFFF` 也是空的，现在你可以把 UCS-2 理解成是 UTF-16 的子集。

### UTF-32 编码方案

接下来我们更快的来过一下 UTF-32 和 UCS-4，他俩都是直接对每个字符都使用 4 个字节，并且刚开始 UCS-4 提出来时，4 个字节，一共 32 个位，但是在计算机中我们一般会把最高位当做符号位（这里是否如此，存疑），那 UCS-2 就有 `2^31 = 2147483648` 个码位，但是因为 UCS-4 要符合 UNICODE 的标准，码位只能用到 `0x10FFFF`，所以 UTF-32 就被提出来了，他只用来表示 `0x000000~0x10FFFF` 的码位。

到这里，有没有发现代理位的坑？明明 UTF-8 和 UTF-32 可以表示更多的字符，但是因为用了代理位，UNICODE 的字符个数上限就被制裁到了 `0x10FFFF`，当然事实也是如此，虽然我们现在还有大量的码位没有被使用，UNICODE 又被称为万国码，但如果以后如果有了宇宙码呢？

## 字符集和编码方案的阶段总结

1. 刚开始由美国提出了 ASCII 初版字符集，并且这也是早期计算机的编码方案，规定 8 个位为 1 个字节，一共有 2^8=256 个码位。
2. 后来因为计算机传到了其他国家，所以后面又出了 ASCII 补码集，把 ASCII 字符集填充满了。
3. 再后来，计算机传到了中国，我们通过特定的规则，将两个 ASCII 码组合，得到了中国汉字编码，同期产生的编码方案有 GB2312、GBK、GB18030 等。
4. 最后，国际标准化组织终止了这种各国创造各自编码方案的行为，打造了 UNICODE，试图将全世界的字符都收纳其中。
5. UNICODE 的码位一共有 `0x10ffff` 个，这些码位被分为 17 个平面，我们常用的是 BMP 平面。
6. 因为 UNICODE 在提出之初直接规定使用 2 个字节，并没有考虑兼容任何编码，包括 ASCII，所以推广十分艰难，直到 UTF-8 编码方案的问世。
7. UNICODE 的 BMP 平面前 127 个码位直接照搬 ASCII，并将 `0xD800~0xDBFF` 和 `0xDC00~0xDFFF` 规定为高低代理位，他俩组合生成辅助平面所需码位。
8. UTF-8 是可变长的编码方案，编码结果是 1~4 个字节，既保证了英文字符的编码结果和 ASCII 初版字符集保持一致，又可以通过特定规则，编码所有的 UNICODE 码位。
9. UTF-16 也是可变长编码方案，编码结果是 2 或者 4 个字节，BMP 平面的字符用 2 个字节表示，辅助平面用高低代理位组合计算后的 4 个字节表示。并且由于没有 UTF-8 的特殊规则，所以存在大小端字节序的问题。
10. UCS-2 是 UTF-16 的前身，编码结果是 2 个字节，不支持辅助平面的字符表示。编码空间为 `0x0000~0xFFFF`。
11. UTF-32 是定长编码方案，编码结果是固定的 4 个字节，和 UTF-16 一样，也存在字节序的问题。
12. UCS-4 是 UTF-32 的前身，编码结果是固定的 4 个字节。编码空间为 `0x00000000~0x7FFFFFFF`。
13. UTF 系列编码方案的编码空间都为 `0x000000~0x10FFFF`。

## 参考 & 建议

### 参考文章

[网页编码就是那点事](http://www.qianxingzhem.com/post-1499.html)
[ASCII 码表](http://www.asciima.com/ascii/12.html)
[Code Charts](https://www.unicode.org/charts/)
[Unicode 和 UTF-8 有什么区别？](https://www.zhihu.com/question/23374078)
[字符编码笔记：ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)
[细说：Unicode, UTF-8, UTF-16, UTF-32, UCS-2, UCS-4](https://www.cnblogs.com/malecrab/p/5300503.html)

### 建议阅读

[ANSI 是什么编码？](https://www.cnblogs.com/malecrab/p/5300486.html)
[汉字编码：GB2312, GBK, GB18030, Big5](https://www.cnblogs.com/malecrab/p/5300497.html)
[细说：Unicode, UTF-8, UTF-16, UTF-32, UCS-2, UCS-4](https://www.cnblogs.com/malecrab/p/5300503.html)
[UTF-8, UTF-16, UTF-32 & BOM](http://unicode.org/faq/utf_bom.html)
[JavaScript’s internal character encoding: UCS-2 or UTF-16?](https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae)
[其实你并不懂 Unicode](https://zhuanlan.zhihu.com/p/53714077)
[JavaScript 如何正确处理 Unicode 编码问题！](https://segmentfault.com/a/1190000017782406)

## 后语

首先来一点前置知识点吧，相信大家用电脑的时候都看过文件属性，比如某图片 2.1K，某文档 128B，这些数字是如何计算出来的？
有办法可以让一个文件表达的内容不变，但是体积变小吗？
MB、KB、B、字节、位，这些单位是什么意思？
byte bit
文件大小验证
画图
在 js 端的应用
知乎文章 字节簇

要把 hex 都转成小写的

<!-- jīnzhéháo -->

## 页脚

代码即人生，我甘之如饴。

> 技术不断在变  
> 头脑一直在线  
> 前端路漫漫  
> 我们下期见
>
> by --- 裤裆三重奏

我在这里 [gayhub@jsjzh](https://github.com/jsjzh) 欢迎大家来找我玩儿。

欢迎小伙伴们直接加我，拉你进群一起搞事情，记得备注一下你是从哪里看到文章的。

<div align="center">
  <image src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53fb3e16b1f64ebbb8aee73734371257~tplv-k3u1fbpfcp-watermark.image" />
</div>

> ps: 如果图片失效，可以加我 wechat: kimimi_king
