# 你需要知道的前端编码

<div align="center">
  <image src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d45a010de01a413ab7101a4479b1ad5e~tplv-k3u1fbpfcp-zoom-1.image" />
</div>

## 大纲「待删」

1. ASCII
   1. GB2312
   2. GBK
   3. GB18030
2. UNICODE
   1. UTF-8
   2. UTF-16
   3. UTF-32

<!-- 其实个人认为 GBK 和 ASCII 应该是同等级的，而不是 ASCII 的下标题，但是为了更好的讲述一个时代的终结和一个时代的开始，所以在感官上将他们分开， -->

## 前言

其实这篇文章是在写上传文件的文章的时候产生的，因为上传文件的时候会涉及到文件的基本组成，还有编码等内容，我又是个不彻底搞清楚就不罢休的人，往往会因为一个小问题牵扯出来一堆问题，接着，疑问又带来新的疑问（禁止套娃！），写这篇文章真的花了很长的时间，如果看完之后有所收获，一个赞就是对我最好的褒奖。

ps: 文章不会纠结一些不太重要的信息，比如某协议是谁提出的，在什么年份提出的，这些基本上看过一次就忘了，也不重要，我会提取重要的信息来分享给大家。

## 正文

首先来一点前置知识点吧，相信大家用电脑的时候都看过文件属性，比如某图片 2.1K，某文档 128B，这些数字是如何计算出来的？
有办法可以让一个文件表达的内容不变，但是体积变小吗？
MB、KB、B、字节、位，这些单位是什么意思？
byte bit

---

众所周知，在计算机中，所有的数据存储和运算时都要使用二进制表示，因为计算机用高电平和低电平表示 1 和 0。然后在美国就有这么一群人，他们决定用 8 个二进制位来表示所有字符。

8 个二进制位，一共可以表示 `2^8 = 256` 个字符，而这些字符又分为控制字符、通信专用字符和可显示字符。

控制字符和通信专用字符放在一起说，第 0~31，再加上 127，一共是 33 个。比如，`0000 0111`，十六进制是 `0x07`，表示的意思是响铃，计算机在接收到 `0000 0111` 的时候就会铃铃作响。

可显示字符，第 32~126，一共是 95 个，比如 `0011 0000`，十六进制是 `0x30`，表示的意思是 0，再比如 `0100 1010`，十六进制是 `0x4A`，表示的是大写英文字母 J。

因为计算机刚开始只在美国使用，那大家相安无事，用的挺好，这就是我们在大学 C 语言里面认识到的 ASCII 码表的由来。

> ps: 现在教育太疯狂了，朋友小孩小学就在学编程，他现在就知道 ASCII 码了

后来，因为计算机的发展，一些西方国家开始在 ASCII 码表的后面增加自己国家的字符和制表符等字符，这就是我们知道的 扩展 ASCII 码表，他占用了 128~255 的位置来表示一些字符。

> ps: 扩展 ASCII 码表在不同系统配置的内码表也不同，这里就不赘述了，想要了解的同学可以参考以下文档

https://baike.baidu.com/item/%E6%89%A9%E5%B1%95ASCII/9882009

再后来，计算机发展的越来越快，来到了第三世界。我们发现，泱泱中华数以万计的文字，ASCII 码表是不可能放下我们的字符了，256 个位置全给我们都不够，那该怎么办？

聪明的中国人直接把 127 号之后的奇怪符号取消掉，规定，一个小于 127 的字符意义与原来相同，但两个大于 127 的字符连在一起时，就表示一个汉字，前面的一个字节（高字节）从 `0xA1~0xF7`，后面一个字节（低字节）从 `0xA1~0xFE`。

这样我们就能组合出八千多个位置来放自己的文字、数学符号、日文假名等，而且，我们甚至把原先在 ASCII 码表里就有的标点符号，又全部编了两个字节长的字符，这就是我们常说的全角字符了，而 127 号以下的就称为半角字符。（「,」和「，」看出不同了吗？前者是半角字符，后者是全角字符）

后来这个方案用着还不错，我们就给它取了个名字 `GB2312`，前面的 GB 意思是国标。

但是中国的汉字实在太多了，八千多个位置还是不够，那我们干脆就不要求低字节是 127 号之后的了，规定只要高字节大于 127，那就是中国编码方案的开始。

这个方案就称为 `GBK`，`GBK` 不仅包括了 `GB2312` 的所有内容，还增加了好多汉字和繁体字。

再后来，少数民族也要用电脑了，要把他们的文字也加进去，于是就再进行扩展，`GBK` 扩成了 `GB18030`。

听起来是不是挺完美的？`GB18030`，几乎可以囊括你能见到的所有中文，但是我们这只解决了中文的编码，无法显示其他国家或者地区的文字，比如，那时候还有一个编码方案叫 `Big5`，普及与台湾、香港、澳门等繁体中文通行区，倚天中文系统、window 繁体中文等系统的字符集都是以 `Big5` 为基准。你看，中国的内地和港澳台编码方式都不一样，我们和其他国家就更不用说了，结果就是，大家都闭门造车，自嗨，如果需要看其他国家的文档那就得配置其他国家的编码方案。

再这么混乱下去肯定不行，这时候，创建一个可以囊括全世界的字符集势在必行，这个时候，有两个组织开始着手统一字符集，国际标准化组织（ISO）开发的 ISO 10646 字符集，统一码联盟开发的 UNICODE 字符集。再后来，两个组织都意识到他们应该做的事情是统一标准而不是重蹈覆辙，于是他们决定合作，最终才有了我们在用的 UNICODE 字符集，当然 ISO 10646 字符集依然存在，并且和 UNICODE 共存，但是他们各自的码位所表达的字符都相同。

「TODO」

现在我们字符集有了，但是字符集只是规定了各个字符的码位，并没有规定这些码位该如何传输和存储，接下来，我们就来看看 UNICODE 和 ISO 10646 的编码方案。

首先是和 UNICODE 相关的，有 UTF-8 UTF-16 UTF-32，和 ISO 10646 相关的有 UCS-2 和 UCS-4，因为我们平时接触的都是 UNICODE，我就在说 UTF 编码方案的时候一起提一下 ISO 的编码方案。

刚开始 UNICODE 的做法很简单，开头的 127 位从 ASCII 直接照搬，然后，ASCII 1 个字节（8 位）不是不够吗，那就 2 个字节（16 位），`2^16 = 65536` 总够了吧？

> 在原先的 ASCII 中，英文字符只占一个字节，UNICODE 这样的规定会让英文字符所占空间翻倍，解决方案也有，往下看即可。

结果是被啪啪打脸，在被各个国家的字符蹂躏了一遍之后，不行，这得改，于是决定取 UNICODE 中的两段区域 `0xD800~0xDBFF`（叫做高代理位）和 `0xDC00~0xDFFF`（叫做低代理位），用他们来组成新的码位。每段代理位都有 1024 位，那就是增加了 `1024^2 = 1048576` 个码位，再加上原先的 `2^16`，一共是 `1114112` 个码位。

「TODO」画一个图，内容如下

<!-- 0x0000                                                                           0xFFFF -->
<!-- 0x0000~0x007F    0x4E00~0x9FFF     0xD800~0xDBFF  0xDC00~0xDFFF    0xE000~0xF8FF -->
<!--     ASCII         2W 多个汉字           高代理位        低代理位         自行使用区 -->

我们看上图，这下就能很清楚网上经常说的 UNICODE BMP 平面是什么意思了，另外，我们刚才不是提到用了高低代理位组合而成的码位么？UNICODE 就把这些码位分成了 17 个平面，网络通信常用的是 BMP 平面，剩下的 16 个平面这里就不介绍了。另外，有兴趣的同学可以到 [这个网站](https://www.unicode.org/charts/) 上查其他平面上对应的字符是什么。

> 例如：`0x1D306`，这是四个横线组成的字符「`𝌆`」（或许你的网页会显示一个 `?`，这有很多原因，或许是浏览器没有正常渲染，或许是站点没有正确存储文章内容，我这里再放一个截图）

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e93ac532fb74f05b4b51e5ab40f74c4~tplv-k3u1fbpfcp-watermark.image)

等等，取代理位的操作是不是很熟悉？看文章仔细的同学应该马上就反应过来了，对，没错，就像当初我们针对 ASCII 而提出的 `GBK` 方案，我们用 127 号以后的 ASCII 码组合出几万个码位给汉字用，UNICODE 也是一样，取了两段代理位组合，就成了其他 16 个平面，那为什么 UNICODE 的码位有几百万，而我们提出的 `GBK` 只有几万，因为 ASCII 只有 1 个字节，UNICODE 有 2 个字节，仅此而已。ASCII 和 UNICODE 本质其实都一样，就是字符集，字节数不同而已。

字符集有了之后，我们该如何把 UNICODE 中各字符的码位转为程序数据？这时候 UTF 编码方案就出现了。

<!-- UTF-8（8位元，Universal Character Set/Unicode Transformation Format）是针对Unicode的一种可变长度字符编码。它可以用来表示Unicode标准中的任何字符，而且其编码中的第一个字节仍与ASCII相容，使得原来处理ASCII字符的软件无须或只进行少部分修改后，便可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。 -->

「TODO」好像并没有便于传输，对于汉字来说

先来说我们最熟悉的 UTF-8，这是一个可变长度的 UNICODE 的编码方式，我们直接通过一个例子来看最方便，要传输”裤裆“两个字，UTF-8 编码是如何转换的，这里有一个表格，是 UTF-8 的替换模板，模板也是有规律的，第几行就有几个字节，并且第一个字节就有几个 1。

| 十六进制范围       | UTF-8 模板                          |
| :----------------- | :---------------------------------- |
| U+ 0000 ~ U+ 007F  | 0XXXXXXX                            |
| U+ 0080 ~ U+ 07FF  | 110XXXXX 10XXXXXX                   |
| U+ 0800 ~ U+ FFFF  | 1110XXXX 10XXXXXX 10XXXXXX          |
| U+10000 ~ U+10FFFF | 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX |

11110XXX 10XXXXXX 10XXXXXX 10XXXXXX
100 001111 111111 111111

```javascript
// 获取”裤“的 UNICODE 码位
const code = "裤".charCodeAt(); // 35044
// 获取 35044 的十六进制表示，88e4 位于上表的第 3 行
const hex = code.toString(16); // 88e4
// 获取 35044 的二进制表示
const binary = code.toString(2); // 1000 1000 1110 0100

// 将二进制带入模板

//          10001000 11100100   |   ”裤“的二进制序列
//     1000   100011   100100   |   ”裤“的二进制排序后
// 1110XXXX 10XXXXXX 10XXXXXX   |   第三行模板
// --------------------------   |   从低位到高位带入模板
// 11101000 10100011 10100100   |   获得二进制序列
//       e8       a3       a4   |   二进制序列转为十六进制

// 最终得到 e8 a3 a4 的编码结果

// 通过 node Buffer 来验证
const buffer = new Buffer.from("裤", "utf-8"); // <Buffer e8 a3 a4>
```

原先 ASCII 的字符平白无故就多了一倍的空间，UTF-8 是一个很聪明的实现方式

我们先来说说 UTF-16。看着和 UTF-8 很像吧，但他们不是 double 的关系，实现方式

UCS-2 UTF-16 大端序 小端序 可变长度 利用代理位 UNICODE 被限制了个数
UTF-8 可变长度
UTF-32

总结，各个英文字符是什么意思

希望看完这篇文章的你，以后再看到 UNICODE 和 UTF-8 有什么区别类似的问题，可以再也无所畏惧

<!-- jīnzhéháo -->

## 正文标题一

## 正文标题二

「TODO」

## 正文标题三

「TODO」

## 后语

「TODO」

## 页脚

代码即人生，我甘之如饴。

> 技术不断在变  
> 头脑一直在线  
> 前端路漫漫  
> 我们下期见
>
> by --- 裤裆三重奏

我在这里 [gayhub@jsjzh](https://github.com/jsjzh) 欢迎大家来找我玩儿。

欢迎小伙伴们直接加我，拉你进群一起搞事情，记得备注一下你是从哪里看到文章的。

<div align="center">
  <image src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53fb3e16b1f64ebbb8aee73734371257~tplv-k3u1fbpfcp-watermark.image" />
</div>

> ps: 如果图片失效，可以加我 wechat: kimimi_king

## 草稿

字符、字节、b、kb、k、mb

- 一个字节等于 8 位
- 2^8 256
- 127 Ascii
- Ascii 扩展字符集
  - 128~256
- 127 以后的字符直接取消，小于 127 的字符意义与原来相同，但两个大于 127 的字符连在一起时，就表示一个汉字
  - 第一个字节从 0xa1 到 0xf7，第二个字节从 0xa1 到 0xfe 7000 多个汉字，还把数学符号、罗马希腊的字母、日文的假名、ascii 中原有的数字、标点、字母都重新编了两个字节长的编码，就是全角字符
  - 这就叫 gb2312
- 只要第一个字节大于 127 就表示一个汉字的开始，这就是 GBK 标准，包括了 gb2312，又增加了 2W 个新的汉字，包括繁体字和符号
- 少数民族要用电脑，再扩展，又加了几千个少数民族的字，成了 gb18030
- 这些编码被称为 DBCS double byte chareter set 双字节字符集
- 台湾 Big5 编码
- ISO 国际标准化组织，废了所有的地区性编码方案，重新搞了一个包括了地球上所有文化、字母和符号的编码，也就是 UCS，俗称 unicode，Universal Multiple-Octet Coded Character Set
  - 直接规定必须用两个字节，也就是 16 位来统一表示所有字符，原先的 Ascii 127 位字符，保持原编码不变，长度由 8 位扩展为 16 位，其他文化和语言的字符全部重新统一编码
    - 原先的半角字符会浪费一倍的空间
- 为解决 unicode 在网络上传输的问题，面向传输的 UTF(UCS Transfer Format) 标准就出现了，UTF-8 就是每次 8 个位传输数据，UTF-16 就是每次 16 个位
  - **UTF-8 是在互联网上使用最广的一种 unicode 的实现方式**，实现方式，这是为传输而设计的编码
    - 是一种变长的编码方式，可以用 1~4 个字节表示一个符号
    - 当字符在 ascii 码的范围时，就用一个字节表示
    - unicode 一个钟文字符占 2 个字节，UTF-8 一个中文字符占 3 个字节

| Unicode 符号范围（十六进制） | UTF-8 编码方式（二进制）            |
| ---------------------------- | ----------------------------------- |
| 0000 0000 ~ 0000 007F        | 0xxxxxxx                            |
| 0000 0080 ~ 0000 07FF        | 110xxxxx 10xxxxxx                   |
| 0000 0800 ~ 0000 FFFF        | 1110xxxx 10xxxxxx 10xxxxxx          |
| 0001 0000 ~ 0010 FFFF        | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |
