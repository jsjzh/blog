# HTTP 查漏补缺

<div align="center">
  <image src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d45a010de01a413ab7101a4479b1ad5e~tplv-k3u1fbpfcp-zoom-1.image" />
</div>

## 大纲「待删」

书写技术文章的顺序

- 查阅资料
- 构思，书写大纲
- 书写内容
- 检查错误、美化文章
- 发布文章

## 小剧场

「TODO」

## 前言

「TODO」

## 正文标题一

「TODO」

## 正文标题二

「TODO」

## 正文标题三

「TODO」

## 后语

「TODO」

## 页脚

代码即人生，我甘之如饴。

> 技术不断在变
> 头脑一直在线
> 前端路漫漫
> 我们下期见
>
> by --- 裤裆三重奏

我在这里 [gayhub@jsjzh](https://github.com/jsjzh) 欢迎大家来找我玩儿。

欢迎小伙伴们直接加我，拉你进群一起搞事情，记得备注一下你是从哪里看到文章的。

<div align="center">
  <image src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53fb3e16b1f64ebbb8aee73734371257~tplv-k3u1fbpfcp-watermark.image" />
</div>

> ps: 如果图片失效，可以加我 wechat: kimimi_king

## 草稿

### HTTP/1.0

[HTTP/1.0 通信](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03ef2a4c4b2a42ad9e0bea5d8145bbbc~tplv-k3u1fbpfcp-zoom-1.image)

每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据、断开 TCP 连接三个阶段。

> 注意：图片、js、css 等外部引用的资源文件，每一个都是一次 HTTP 通信。

#### 总结

HTTP/1.0 引入了请求头和响应头，主要是为了支持多种类型的文件下载，其次还提供了 Cache 机制、用户代理、状态码等基础信息。

### HTTP/1.1

1. 增加了持久连接，一个 TCP 可以进行发送多个 HTTP 请求
   1. 请求头增加 `Connection: keep-alive`
2. Chrome 浏览器为每个域名提供 6 个 TCP 持久连接
3. 提供虚拟主机支持，每个虚拟主机都有自己的单独域名，公用同一个 IP 地址
   1. 请求头增加 `Host: xxx`
4. 对动态生成的内容提供支持
   1. 引入 Chunk transfer 机制，服务器将数据分成若干个任意大小的数据块，每个数据块发送时附带上一个数据块的长度，最后用一个零长度的块作为发送完成的标志
5. 客户端 Cookie
6. 其它安全机制

#### 持久连接

[HTTP/1.1 通信](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdce1bd9b1494491b3a43204f172eebe~tplv-k3u1fbpfcp-zoom-1.image)

增加了**持久连接**的方法，在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器和服务器没有明确断开连接，该 TCP 连接就会一直保持。

默认开启，开启方式是在请求头增加 `Connection: keep-alive`。

对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。

好处是通过减少 TCP 建立连接和断开连接的次数，减少服务器负担，提升了整体 HTTP 的请求时间。

但是持久连接需要等待前面的请求返回后才能进行下一次请求，如果 TCP 通道中某个请求没有及时返回，就会阻塞后面的所有请求，这就是**队头阻塞**的问题。

另外，通过引入 CDN，再加上每个域名可以同时建立 6 个 TCP 持久连接，那原先 100 个资源下载需要的时间为 100 \* n \* RTT，现在只需要 100 \* n \* RTT / 6 / CDN 个数。

##### HTTP 管线化

> HTTP/1.1 试图通过管线化的技术来解决队头阻塞的问题，将多个 HTTP 请求整批提交给服务器，但是服务器依然需要根据请求顺序来恢复浏览器的请求。

#### 虚拟主机的支持

「不是很懂什么意思」

「解答：就是访问同一个域名的时候，他只有一个 IP 地址，但是某个 IP 地址背后可以有多个虚拟主机，每个虚拟主机的域名可以不同，那访问到 IP 的主机后，再根据 Host 去访问对应的的虚拟主机」

请求头增加了 `Host` 字段，用来表示当前的域名地址，服务器可以根据不同的 `Host` 值做不同的处理。

#### 对动态生成的内容提供了支持「存疑」

「难道不都是通过 ajax 获取数据然后渲染的么？这里的不知道数据大小是什么意思？难道是传输文件的数据大小？」

在 HTTP/1.0，需要在响应头设置完整的数据大小，如 `Content-Length: xxx`，但是随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，导致浏览器不知道何时会接收完所有的数据。

HTTP/1.1 引入 Chunk transfer 机制解决这个问题，服务器将数据分割成若干个任意大小的数据块，每个数据块发送时会带上上一个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。

#### 客户端 Cookie、安全机制

HTTP/1.1 引入了 Cookie。

#### 存在的问题

##### 对带宽的利用率不理想

> 带宽是指每秒最大能发送或接收的字节数，每秒能发送的最大字节数称为上行带宽，每秒能接收的最大字节数称为下行带宽。

原因：

- TCP 的慢启动

一个 TCP 连接建立之后，刚开始会采用一个非常慢的速度去发送数据，然后慢慢加快速度，这个过程称为**慢启动**，并且慢启动是 TCP 为了减少网络拥塞的一种策略，是没有办法改变的。

- 同时开启多条 TCP 连接，连接之间会竞争固定的带宽

浏览器同时建立多条 TCP 连接后，每个连接速度慢慢增加，一旦带宽不足，TCP 连接就会动态减慢下载速度，而有的 TCP 下载的是关键资源，比如 js、css，有的 TCP 下载的是图片、视频等不关键资源。无法协商哪些资源需要被优先下载，就会影响关键资源的下载速度

- 队头阻塞的问题

一个 TCP 中有多个 HTTP 请求，虽然能够公用一个 TCP 管道，但是一个管道内同一时刻只能处理一个请求，当前的请求没有结束之前，其他请求只能处于阻塞状态

TCP 的慢启动，TCP 连接之间的相互竞争是 TCP 本身的机制导致的；  
队头阻塞是由于 HTTP/1.1 的机制导致的。

### HTTP/2

一个域名只使用一个 TCP 长连接来传输数据，这样一个 TCP 连接只需要一次慢启动，也避免了多个 TCP 连接竞争带宽。

另外，HTTP/2 还实现了资源的并行请求，消除了队头阻塞的问题，任何时候都可以将请求发送给服务器，服务器也可以随时返回处理好的请求资源。

#### 多路复用机制「存疑」

「我本来以为是每个请求一个 ID，现在看起来是每个请求还可以被分割成 header 和数据体，他们拥有同一个 ID，然后浏览器接收到相同的 ID 之后会把他们拼接成完整的 HTTP 响应数据」

[HTTP/2 通信](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1f7f6402c09457e94860cb910f29423~tplv-k3u1fbpfcp-zoom-1.image)

看上图，每个请求都有一个对应 ID。

> 服务器端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容，比如服务器可能早就缓存好了 index.html 和 bar.js 的响应头信息，那么当接收到请求的时候就可以立即把 index.html 和 bar.js 的响应头信息返回给浏览器，然后再将 index.html 和 bar.js 的响应体数据返回给浏览器。之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。

##### 多路复用实现「存疑」

「为什么这就实现多路复用了？我的理解是现在还是需要一个个发送数据，并且还多了一个二进制分帧层，发送的时候多了转换时间，到了服务端还多了拼接时间，返回的时候也是一样，多了很多时间」

[分层](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50cd9acb229f4e3b85523dcd600d1544~tplv-k3u1fbpfcp-zoom-1.image)

1. 浏览器准备好请求数据，包括请求行、请求头等信息，如果是 POST 方法，还有请求体。
2. 数据经过**二进制分帧层**处理后，被转换成一个个带有 ID 的帧，通过协议栈将这些帧发送给服务器。
3. 服务器接收到所有帧之后，将相同 ID 的帧合并为一条完整的请求信息。
4. 服务器处理该请求，将处理的响应行、响应头和响应体分别发送至**二进制分帧层**。
5. 同样，二进制分帧层会将这些响应数据转换成一个个带有 ID 编号的帧，通过协议栈发送给浏览器。
6. 浏览器接收到响应帧后，根据 ID 将帧数据拼接返回给对应请求。

#### 其他特性

- 可以设置请求的优先级
- 服务器推送
  - 当用户请求一个 html 文件，服务器知道该 html 页面会引用几个重要的 js、css 文件，这个时候附带将 css 和 js 文件一并发送给浏览器。
- 头部压缩

#### 存在的问题

#### TCP 的队头阻塞

HTTP/2 解决的是应用层面的队头阻塞问题，不过依旧是基于 TCP 协议，而 TCP 最初就是为了单连接而设计的。

[HTTP/1.1 协议栈 TCP 如何传输数据](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d2d8956e8e54f2795fb53ae4f67ae97~tplv-k3u1fbpfcp-zoom-1.image)

[HTTP/1.1 的 TCP 的队头阻塞](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe2ffcbacf58446cbfb867edd4e06a83~tplv-k3u1fbpfcp-zoom-1.image)

[HTTP/2 协议栈 TCP 如何传输数据](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0d1a198c0964c099ecce99153c6ef40~tplv-k3u1fbpfcp-zoom-1.image)

所以，因为 TCP 还是单个传送的，如果数据出现丢包的情况，就会阻塞该 TCP 连接中的所有请求，并且 HTTP/2 单个域名只有一个 TCP 连接，相比较 HTTP/1.1，每个域名可以有 6 个 TCP 连接。

如果丢包率很高，达到 2% 的话，HTTP/1.1 的传输效率反而比 HTTP/2 更好。

#### TCP 建立连接的延时「存疑」

「这里稍微有点没搞懂 HTTP 四次握手和 TCP 建立连接有什么关系」

网络延迟（RTT: Round Trip Time）：从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT。

1. 在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，需要消耗 1.5 个 RTT 之后才能进行数据传输
2. 进行 TLS 连接，TLS 有两个版本，TLS 1.2 和 TLS 1.3，每个版本建立所花的时间不同，大致需要 1~2 个 RTT

如果浏览器和服务器的物理距离近，一个 RTT 的时间在 10ms 以内，如果相隔较远，一个 RTT 可能需要 100ms 以上。

#### TCP 协议僵化

TCP 协议存在队头阻塞和建立连接延时等缺点，是否可以改进 TCP 协议来解决问题？非常困难。

中间设备的僵化，像是路由器、防火墙、交换机等等，他们依赖的软件使用了大量的 TCP 特性，这些功能被设置了之后就很少更新了。

所以如果升级了 TCP 协议，当新的协议数据包经过中间设备时，这些中间设备可能不理解包内容，数据包会被丢弃。

除了中间设备僵化，操作系统也是一个原因，因为 TCP 协议是通过操作系统内核来实现的，应用程序只能使用不能修改，通常操作系统的更新都滞后于软件的更新，所以想要更新内核中的 TCP 协议也非常困难。

### HTTP/3「存疑」

「所以，UDP 协议是咋样的」

QUIC 协议（Qiuck UDP Internet Connections）

基于 UDP 协议，实现了类似 TCP 的多路数据流、传输可靠性等功能

[HTTP/3 和 HTTP/2 对比](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79b93e58ca204f538643eb3892e40882~tplv-k3u1fbpfcp-zoom-1.image)

- 通过提供数据包重传、拥塞控制以及其他一些 TCP 存在的特性来保证 UDP 传输的可靠性
- 继承了 TLS 加密功能
- 实现了 HTTP/2 中的多路复用，和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流

[QUIC 传输数据](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37f83ba6b15a45a4a270389ff224039e~tplv-k3u1fbpfcp-zoom-1.image)

- 实现了快速握手功能，由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这样可以大大提升首次打开页面的速度

#### HTTP/3 需要面对的问题

- 服务器和浏览器都没有对 HTTP/3 提供比较完整的支持
- 部署 HTTP/3 也存在很大问题，因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度
- 中间设备僵化的问题，这些设备对 UDP 的优化程度远远低于 TCP
