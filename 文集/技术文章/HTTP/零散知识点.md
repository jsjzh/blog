## get 和 post 的区别

get 会产生一个 tcp 数据包，post 会产生两个

get 请求会把 headers 和 data 一起发送出去，服务器响应 200

post 请求时，浏览器先发送 headers，服务器响应 100 continue，浏览器再发送 data，服务器响应 200

## 五层因特网协议栈

应用层发送 http 请求，传输层通过三次握手建立 tcp/ip 链接，网络层 ip 寻址，数据链路层封装成帧，物理层利用物理介质传输

1. 应用层（dns, http）DNS 解析成 IP 并发送 http 请求
2. 传输层（tcp, udp）建立 tcp 连接（三次握手）
3. 网络层（IP, ARP）IP 寻址
4. 数据链路层（PPP）封装成帧
5. 物理层（利用物理介质传输比特流）

### OSI 七层框架

物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

## 负载均衡

nginx 控制负载均衡，一个 ip 对应多个虚拟主机，负载均衡

负载均衡也有问题，每个机器如何实现调度以及缓存如何利用

## cookie

静态资源若和接口同地址，会导致请求报文都带上 cookie，导致请求过大

## 多域名拆分

在移动端，如果请求的域名数过多，会降低请求速度

dns-prefetch 让浏览器空闲时间提前解析 dns 域名

## 长连接与短连接

长连接：一个 tcp 连接上可以发送多个 http 请求，在 tcp 保持期间，如果没有数据包发送，需要双方发检测包以维持此连接
短连接：http/1.0 的模式，一个 http 请求一个 tcp 连接

keep-alive 不会永远保持，有一个持续时间，在服务器中可以配置

## https 加密流程「存疑」

1. 浏览器请求简历 SSL 连接，并向服务端发送一个随机数 client random 和客户端支持的加密方法，比如 RSA 加密，此时是明文传输
2. 服务端从中选出一组加密算法与 hash 算法，回复一个随机数 server random，并将自己的身份信息以证书的形式发挥给浏览器（证书里面包含了网站地址，非对称加密的公钥，证书颁发机构等信息）
3. 浏览器收到证书后
   1. 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样）
   2. 用户接收证书后（不管信不信任），浏览器会产生新的随机数 premaster secret，然后证书中的公钥以及指定的加密方法加密，发送给服务器
   3. 利用 client random、server random 和 premaster secret 通过一定的算法生成 http 连接数据传输的对称加密 key session key
   4. 使用约定好的 hash 算法计算握手消息，并使用生成的 session key 对消息进行加密，最后将之前生成的所有信息发送给服务端
4. 服务端收到浏览器的恢回复
   1. 利用已知的加解密方式与自己的私钥进行解密，获取 premaster secret
   2. 和浏览器相同规则生成 session key
   3. 使用 session key 解密浏览器发来的握手消息，并验证 hash 是否与浏览器发来的一直
   4. 使用 session key 加密一段握手消息，发送给浏览器
5. 浏览器解密并计算握手消息的 hash，如果与服务端发来的 hash 一致，此时握手过程结束

之后所有的 https 通信数据将由之前浏览器生成的 session key 并利用对称加密算法进行加密
